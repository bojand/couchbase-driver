<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import _ from 'lodash';
import async from 'async';
import { errors } from 'couchbase';

const debug = require('debug')('lounge');

const DBOPS = {
  UPSERT: 'upsert',
  REMOVE: 'remove',
  NOOP: 'noop'
};

const defaultOptions = {
  atomicRetryTimes: 5,
  atomicRetryInterval: 0,
  missing: true
};

export default class Driver {
  /**
   * @classdesc Couchbase driver util class. Just wraps couchbase Bucket and overrides some functions.
   *
   * @param {Object} bucket the Couchbase &lt;code>Bucket&lt;/code>
   * @param options {Object} Options
   * @param {Number} options.atomicRetryTimes - The number of attempts to make within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>5&lt;/code>.
   * @param {Number} options.atomicRetryInterval - The time to wait between retries, in milliseconds, within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>0&lt;/code>.
   * @param {Boolean} options.missing - Whether to return missing. If &lt;code>false&lt;/code> Does not return.
   *                                    Useful for certain contexts.
   * @class
   */
  constructor(bucket, options) {
    this.bucket = bucket;
    this.config = _.defaults(options || {}, defaultOptions);
  }

  /**
   * Get operation enums
   */
  get OPERATIONS() {
    return DBOPS;
  }

  /**
   * Get operation enums
   */
  static get OPERATIONS() {
    return DBOPS;
  }

  /**
   * Determines if error is a "key not found" error
   */
  static isKeyNotFound(err) {
    let keyNotFound = false;
    if (err &amp;&amp; _.isObject(err)) {
      if (err.code &amp;&amp; err.code === errors.keyNotFound) {
        keyNotFound = true;
      } else if (err.message &amp;&amp; err.message === 'key not found') {
        keyNotFound = true;
      } else if (err.message &amp;&amp; err.message.indexOf('key does not exist') >= 0) {
        keyNotFound = true;
      } else if (err.message &amp;&amp; err.message.indexOf('key not found') >= 0) {
        keyNotFound = true;
      } else if (err.code &amp;&amp; err.code.toString() === '13') {
        keyNotFound = true;
      }
    }

    return keyNotFound;
  }

  /**
   * A simplified get. Properly handles key not found errors. In case of multi call, returns array of found
   * and an array of misses.
   * @param {String|Array} keys - a single key or multiple keys
   * @param {Object} options - Options for bucket &lt;code>get&lt;/code> function
   * @param {Boolean} options.missing - Whether to return missing. If &lt;code>false&lt;/code> Does not return.
   *                                    Useful for certain contexts. This option takes presidence over the one set in
   *                                    constructor.
   * @param {Function} fn callback
   */
  get(keys, options, fn) {
    if (options instanceof Function) {
      fn = options;
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!keys || (Array.isArray(keys) &amp;&amp; !keys.length)) {
      return process.nextTick(() => {
        return fn();
      });
    }

    if (Array.isArray(keys)) {
      debug(`driver.getMulti. keys: ${keys}`);
      this.bucket.getMulti(keys, (err, getRes) => {
        if (err &amp;&amp; _.isObject(err)) {
          return fn(err);
        }

        const misses = [];
        const results = [];
        let errors = [];

        keys.forEach(k => {
          if (getRes.hasOwnProperty(k) &amp;&amp; getRes[k]) {
            if (getRes[k].value) {
              results.push({
                value: getRes[k].value,
                cas: getRes[k].cas
              });
            } else if (getRes[k].error &amp;&amp; Driver.isKeyNotFound(getRes[k].error)) {
              misses.push(k);
            } else if (getRes[k].error) {
              errors.push([getRes[k].error]);
            }
          }
        });

        if (errors.length === 0) {
          errors = null;
        }

        if (this.config.missing === false) {
          if (options.missing === true) {
            return fn(err, results, misses);
          }

          return fn(err, results);
        }

        if (options.missing === false) {
          return fn(err, results);
        }

        return fn(errors, results, misses);
      });
    } else {
      debug(`driver.get. keys: ${keys}`);
      this.bucket.get(keys, options, (err, getRes) => {
        if (err &amp;&amp; Driver.isKeyNotFound(err)) {
          err = null;
        }

        return fn(err, getRes);
      });
    }
  }

  /**
   * Our implementation of Bucket.remove that properly ignores key not found errors.
   * @param {String} key - document key to remove
   * @param {Object} options - Options to pass to Bucket.remove
   * @param {Function} fn - callback
   */
  remove(key, options, fn) {
    if (options instanceof Function) {
      fn = options;
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!key) {
      return process.nextTick(() => {
        return fn();
      });
    }

    debug(`Driver.remove. key: ${key}`);
    this.bucket.remove(key, options, (err, rres) => {
      if (err &amp;&amp; Driver.isKeyNotFound(err)) {
        err = null;
      }

      return fn(err, rres);
    });
  }

  /**
   * Performs an "atomic" operation where it tries to first get the document given the &lt;code>key&lt;/code>, then perform
   * the function &lt;code>transform&lt;/code> on the value and then write using the CAS value in the &lt;code>upsert&lt;/code>.
   * If the upsert fails due to a CAS value error, the whole process is retried.
   * @param {String} key - document key
   * @param {Function} transform - synchronous function to be performend on the document value
   * @param {String} options - Options
   * @param {Number} options.atomicRetryTimes - The number of attempts to make within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>5&lt;/code>.
   * @param {Number} options.atomicRetryInterval - The time to wait between retries, in milliseconds, within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>0&lt;/code>.
   * @param {Function} fn - callback
   */
  atomic(key, transform, options, fn) {
    if (options instanceof Function) {
      fn = options;
      options = {};
    }

    const retryOptions = _.defaults(options || {}, this.config);

    async.retry(retryOptions, rfn => {
      this.get(key, (err, doc) => {
        if (err) {
          return rfn(err);
        }

        const opr = transform(doc ? doc.value : undefined);
        const opts = doc ? { cas: doc.cas } : {};
        if (opr.action === DBOPS.NOOP) {
          return rfn(null, opr.value);
        } else if (opr.action === DBOPS.UPSERT &amp;&amp; opr.value) {
          return this.bucket.upsert(key, opr.value, opts, rfn);
        }
        return this.bucket.remove(key, opts, rfn);
      });
    }, fn);
  }

  /**
   * Create a Driver object by wrapping the Couchbase bucket and returning a new &lt;code>Driver&lt;/code> instance.
   * @param bucket {Object} The Couchbase &lt;code>Bucket&lt;/code> instance to wrap.
   * @param options {Object} Options
   * @param {Number} options.atomicRetryTimes - The number of attempts to make within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>5&lt;/code>.
   * @param {Number} options.atomicRetryInterval - The time to wait between retries, in milliseconds, within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>0&lt;/code>.
   * @returns {Driver}
   * @example
   * const cluster = new couchbase.Cluster('couchbase://127.0.0.1');
   * const bucket = cluster.openBucket('default');
   * const driver = Driver.create(bucket);
   */
  static create(bucket, options) {
    const bucketPrototype = Object.getPrototypeOf(bucket);

    const fnNames = [];
    let p;
    for (p in bucketPrototype) {
      if (bucketPrototype.hasOwnProperty(p) &amp;&amp; p.charAt(0) !== '_' &amp;&amp;
        typeof bucketPrototype[p] === 'function' &amp;&amp; !Driver.prototype[p]) {
        fnNames.push(p);
      }
    }

    fnNames.forEach(fnName => {
      Driver.prototype[fnName] = function () {
        this.bucket[fnName](...arguments);
      };
    });

    return new Driver(bucket, options);
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Driver.html">Driver</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Jul 25 2016 18:17:00 GMT-0300 (ADT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
